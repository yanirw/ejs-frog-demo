name: CI Pipeline

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:  # Manual trigger for testing

permissions:
  contents: write
  pull-requests: write
  security-events: write

env:
  JF_URL: ${{ secrets.JF_URL }}
  JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
  IMAGE_NAME: ejs-frog-demo
  BUILD_NAME: ejs-demo

jobs:
  dependency-scan:
    name: Dependency Security Scan
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Frogbot Security Scan
      uses: jfrog/frogbot@v2.26.3
      env:
        JF_URL: ${{ env.JF_URL }}
        JF_ACCESS_TOKEN: ${{ env.JF_ACCESS_TOKEN }}
        JF_GIT_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        JF_WATCHES: "npm-security-watch"
        JF_INCLUDE_ALL_VULNERABILITIES: "true"

  build-and-publish:
    name: Build, Scan & Publish
    runs-on: ubuntu-latest
    needs: dependency-scan
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        
    - name: Setup JFrog CLI
      uses: jfrog/setup-jfrog-cli@v4
      env:
        JF_URL: ${{ env.JF_URL }}
        JF_ACCESS_TOKEN: ${{ env.JF_ACCESS_TOKEN }}
        JF_GIT_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Install & Audit Dependencies
      run: |
        # 1. Collect Environment & Git Info
        jf rt bce ${{ env.BUILD_NAME }} ${{ github.run_number }} 
        jf rt bag ${{ env.BUILD_NAME }} ${{ github.run_number }} 
        
        # 2. Configure Artifactory Resolution
        jf npmc --repo-resolve demo-dev-npm
        
        # 3. Curation Audit
        jf ca
        
        # 4. Clean Install (Recorded in Build Info)
        jf npm cache clean --force
        rm package-lock.json || true
        jf npm i --omit dev --build-name=${{ env.BUILD_NAME }} --build-number=${{ github.run_number }}


    - name: Build Docker Image
      run: |
        IMAGE_TAG=${{ github.run_number }}
        FULL_IMAGE="${{ vars.DOCKER_REPO }}/${{ env.IMAGE_NAME }}"
        
        echo "Building image: $FULL_IMAGE:$IMAGE_TAG"
        # We pass JF_TOKEN if needed, though we removed it from Dockerfile mostly. Kept for safety if args remain.
        jf docker build -t $FULL_IMAGE:$IMAGE_TAG --build-arg JF_TOKEN=${{ env.JF_ACCESS_TOKEN }} .
        
    - name: Local Xray Docker Scan
      run: |
        IMAGE_TAG=${{ github.run_number }}
        FULL_IMAGE="${{ vars.DOCKER_REPO }}/${{ env.IMAGE_NAME }}"
        
        echo "üõ°Ô∏è Scanning Docker image locally..."
        jf docker scan $FULL_IMAGE:$IMAGE_TAG --watches="docker-security-watch" --fail=false

    - name: Push Docker Image
      run: |
        IMAGE_TAG=${{ github.run_number }}
        FULL_IMAGE="${{ vars.DOCKER_REPO }}/${{ env.IMAGE_NAME }}"
        
        echo "Pushing image: $FULL_IMAGE:$IMAGE_TAG"
        jf docker push $FULL_IMAGE:$IMAGE_TAG --build-name=${{ env.BUILD_NAME }} --build-number=${{ github.run_number }}

    - name: Publish Build Info
      run: |
        echo "Publishing build info..."
        # Note: 'jf rt bp' publishes the collected info from all previous steps (bce, bag, npm i, docker push)
        jf rt bp ${{ env.BUILD_NAME }} ${{ github.run_number }}
